 Project0 Report:  Anthony Devesa(6224283) Parshatd Govindasamy(6378670) Rahuul Rangaraj(6360064)                              

a) Our experience installing NACHOS with platform details. NACHOS(Not Another Completely Heuristic Operating System) project 0, using version 3.4, provided an opportunity to explore the foundations of operating systems through a simulated environment. Anthony: We each installed Nachos on our own system, working together after class. I was able to install it though ssh, without any issue. When I run. /nachos, it initializes a loop of two threads 0, and 1 alternating execution between the two showing how nachos schedules threads. When we ran the -x .../test/halt command you could see the same loop of two threads 0, and 1 and when finished the halt command executes a syscall terminating nachos. With the last part of the assignment, we only added a -s flag which enabled scheduler trace, which shows how nachos schedules decisions. Rahuul: We understood that UNIX is a family of operating systems that use a hierarchical file system where files and directories are organized in a tree structure. A shell, like bash, provides a command-line interface to interact with the system using commands like ls (list files), cd (change directory), mkdir (create directory), pwd (print current directory), and more. Other commands like wget (download files), tar (extract archives), gcc (compile C programs), make (build software using a Makefile), and ssh (securely connect to remote machines), are essential tools for working in UNIX environments. I was able to run the codes utilizing the windows command prompt. First by establishing a connection with the @wolf.cs.fiu.edu, to log into the wolf server. I observed the key commands that involved in creating directories (mkdir nachos), extracting files (tar xzvf), compiling (make), and executing programs (./threads/nachos). To run user programs like halt under NACHOS, I used (./nachos -x ../test/halt), with an option for single-step debugging (./nachos -s -x ../test/halt). It runs the halt program with single-step execution and it displays internal details like register states, pending interrupts, and system. This process helped us gain knowledge on how NACHOS operates and handles user applications. Parshatd: I was able to easily install Nachos using VS Code. This was done through an SSH connection that I made to the wolf.cs.fiu.edu remote Linux server. To perform this, I had to first install and set up the VS Code Remote – SSH extension. This extension made it easier to make the ssh connection.  After connecting, I was able to use the VS Code terminal to execute the command to download the Nachos archive and extract (using commands “tar -xvzf nachos-3.4-linux.tar.gz”) as well as compile/build the code. The integrated environment that VS Code has was extremely helpful for me as it makes it easier to navigate through the directories as well as monitor the terminal output. There were no issues with installing Nachos and all required tools, such as GCC and Make were readily available in the server when checked using the commands “gcc –version” and  “make –version”.                                                                                        

b)We were able to download and extract Nachos using “tar -xvzf nachos-3.4-linux.tar.gz”. After that, We were able to compile Nachos using the make command. Once that was done, we used “cd” to change directories to the threads subdirectory where we ran the basic thread scheduling demonstration by using the command “./nachos”. The output that we received was exactly the same as the one provided in the manual. Threads 0 and 1 were looping in an alternate manner during the thread scheduling and the program halted after completing all scheduled threads. In the  ./nachos -x ../test/halt , -x <executable> specifies the user program (in MIPS format) to be executed in the Nachos simulation. After running the code, it brings up the Nachos system, loads the MIPS-compiled program halt from the test directory and runs the halt program, which triggers the Halt() system call to terminate the machine. In  ./nachos -s -x ../test/halt , the -s (single-step mode), enables step-by-step execution of Nachos. It runs the halt program with single-step execution and it displays internal details like register states, pending interrupts, and system transitions at each step. With  ./nachos -rs 123 -x ../test/halt , the sequence of thread scheduling and execution will be based on the random seed 123. We observed information that showed ticks, pending interrupts and machine register states.  We believe this ensures reproducibility of tests, helps identify and fix bugs related to thread scheduling. Now if we didn’t use -rs, without -rs thread preemption would occur randomly based on the system's default random number generator. This could lead to non-deterministic results when testing concurrent threads. Running the same program with the same seed will always produce the same behavior (deterministic execution)


c) Description of Thread Class in NACHOS: A thread basically represents the sequential execution of code within a program.The thread has state which includes the program counter, which tracks the current instruction being executed, the processor registers, which store temporary data and computation results, and the execution stack, which manages function calls, local variables, and control flow during execution. In Nachos, the system begins executing as a single Unix process, which is transformed into a single Nachos thread by default. This thread executes until the entry-point routine, main, returns, at which point the thread exits. However, the Unix process continues if additional threads have been created, only terminating once all threads are finished. We learned that threads allow for concurrent execution within a single process, sharing the same address space while maintaining private local stacks. A key distinction between threads and processes is the sharing of global variables among threads, which actually necessitates synchronization and mutual exclusion to manage shared memory. Nachos threads execute the same source code and share global variables, with the Nachos scheduler managing thread execution. Threads in Nachos are maintained in a "ready list," which tracks threads prepared to execute. The scheduler follows a simple, round-robin policy, appending threads to the end of the ready list and selecting the thread at the front for execution. Thread states in Nachos include READY, for threads with all resources except the CPU, and other states for threads waiting on resources like I/O or memory. Scheduling is implemented through routines in the Scheduler object, ensuring efficient thread execution and CPU utilization.
